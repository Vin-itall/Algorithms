These algorithms are implemented for self learning purposes, they might not be the most efficient implementations.

Problem Statements:

i. Dijkstra's Algorithm

    implement dijkstra's algorithm, BFS and DFS. Find shortest path between A and E in the following graph using Dijikstra's.

    Nodes - distance

    A B 10

    B C 5

    A D 15

    C E 20

    D E 15

    B E 35 

ii. Leveshtein Distance
    
    Levenshtein distance (LD) is a measure of the similarity between two strings, which we will refer to 
    as the source string (s) and the target string (t). The distance is the number of deletions, insertions, 
    or substitutions required to transform s into t. For example,

    If s is "test" and t is "test", then LD(s,t) = 0, because no transformations are needed. The strings are already identical.
    If s is "test" and t is "tent", then LD(s,t) = 1, because one substitution (change "s" to "n") is sufficient to transform s 
    into t. 

    The greater the Levenshtein distance, the more different the strings are. 
    
iii.Huffman's Encoding
     Huffman coding is a lossless data compression algorithm. In this algorithm, a variable-length code is assigned to 
     input different characters.
     The code length is related to how frequently characters are used. Most frequent characters have the 
     smallest codes and longer codes for least frequent characters.

     There are mainly two parts. First one to create a Huffman tree, and another one to traverse the tree to find codes.

     For an example, consider some strings “YYYZXXYYX”, the frequency of character Y is larger than X and the character Z has 
     the least frequency. So the length of the code for Y is smaller than X, and code for X will be smaller than Z.
